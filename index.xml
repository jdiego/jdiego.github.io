<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terminal</title>
    <link>https://jdiego.github.io/</link>
    <description>Recent content on Terminal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Jun 2021 10:32:20 -0300</lastBuildDate><atom:link href="https://jdiego.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction to Functional Programming</title>
      <link>https://jdiego.github.io/posts/intro-fp/</link>
      <pubDate>Tue, 15 Jun 2021 10:32:20 -0300</pubDate>
      
      <guid>https://jdiego.github.io/posts/intro-fp/</guid>
      <description>Introduction to Functional Programming (FP) Functional Programming (FP) is an old programming paradigm that was born in academia during the 1950s; it stayed restrict tied to that environment for decades. Although it was always a hot topic for scientific researchers, it was never popular in the industry. Instead, imperative languages (procedural and object-oriented) became the mainstream programming languages.
However, in the past few years, we have seen a boost in the popularity of the functional programming paradigm.</description>
      <content>&lt;h1 id=&#34;introduction-to-functional-programming-fp&#34;&gt;Introduction to Functional Programming (FP)&lt;/h1&gt;
&lt;p&gt;Functional Programming (FP) is an old programming paradigm that was born in academia during the 1950s; it stayed restrict tied to that environment for decades. Although it was always a hot topic for scientific researchers, it was never popular in the industry. Instead, imperative languages (procedural and object-oriented) became the mainstream programming languages.&lt;/p&gt;
&lt;p&gt;However, in the past few years,  we have seen a boost in the popularity of the functional programming paradigm. However, instead of functional programming languages becoming the most popular, something else is happening: the most popular programming languages have started introducing features inspired by functional programming languages. Consequently, we can state that functional programming has burst the academic bubble and now it is among us, albeit in an unexpected way, but life is complicated.&lt;/p&gt;
&lt;p&gt;But, what is functional programming after all? Well, answering this question is very complicated because no widely accepted definition exists. But don&amp;rsquo;t panic. The lack of a broadly accepted definition it&amp;rsquo;s quite common when we are talking about programming languages,  and being honest it&amp;rsquo;s common in other computer science topics&amp;hellip;&lt;/p&gt;
&lt;p&gt;People usually tend to define FP through features related to functional concepts in their favourite language. In the FP context, concepts including pure functions, lazy evaluation, pattern matching are frequently mentioned. But defining functional programming in this way is alienate people. The focus shouldn&amp;rsquo;t be on particular language features. We need a better definition to avoid language bias. And I know that many object-oriented programming books apply this strategy to define what is an object-oriented language, but it&amp;rsquo;s out of scope for now, and this isn&amp;rsquo;t the way definitely.&lt;/p&gt;
&lt;p&gt;In programming, we keep decomposing a problem until you reach the level of detail that you can deal with, solve each subproblem in turn, and re-compose the solutions bottom-up. There are, roughly speaking, two ways of doing it: by commanding the computer what to do, or by telling it how to do it. This difference originated the terms &lt;em&gt;declarative&lt;/em&gt; and &lt;em&gt;imperative&lt;/em&gt; programming.&lt;/p&gt;
&lt;p&gt;Broadly speaking, Functional Programming is a declarative &lt;em&gt;style of programming&lt;/em&gt; in which the main program building blocks are functions as opposed to objects and procedures. A program written in the functional style doesn’t specify the instructions that should be performed to produce the outcome but rather it defines what the outcome is.&lt;/p&gt;
&lt;p&gt;Be advised: The way we write a function in the functional paradigm is different from the way we write functions in the procedural style. Functional programming focuses on expressions, while Procedural programming focuses on statements.  Don&amp;rsquo;t worry, I know that things can be a bit blurry now. Then, let&amp;rsquo;s consider a small example to illuminate our thoughts: A program to calculate the sum of a list of numbers.&lt;/p&gt;
&lt;p&gt;The imperative version of this program is usually described as a sequence of actions ordered in time.  Thus we implement this by iterating over the number list and adding the numbers to the accumulator variable. So, we are just describing the sequence of interdependent steps (fine-grained instructions) of how to sum a list of numbers and modifying the state of some conceptual state machine.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accumulate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; numbers) 
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; acc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; number : nuumbers)
        acc &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; number;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;On the other hand, in the declarative version, you need to define only what a sum of a list of numbers is. The computer knows what to do when it’s required to calculate a sum. One way you can do this is to say that the sum of a list of numbers equals the first element of the list added to the sum of the rest of the list and that the sum is zero if the list is empty. You define what the sum is without explaining how to calculate it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; iterator &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accumulate_impl&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; iterator begin, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; iterator end)
{ 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (begin &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; end) &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; accumulate_impl(begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, end) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;accumulate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; numbers)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; accumulate_impl(numbers.cbegin(), numbers.cend());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can notice that the code presented above avoids state and mutable data. It emphasizes the application of functions. Also, we can see that iteration isn&amp;rsquo;t the predominant control structure anymore.&lt;/p&gt;
&lt;h2 id=&#34;imperative-vs-declarative-programming&#34;&gt;Imperative vs. Declarative programming&lt;/h2&gt;
&lt;p&gt;This post could be very abstract until this moment, so to clarify the concepts, let&amp;rsquo;s look at a more elaborate but still simple program implemented in the imperative style and its functional equivalent. The main goal here is demonstrate the difference between these two approaches.&lt;/p&gt;
&lt;p&gt;Here we go: Imagine that we want to write a function that takes a list of files and calculates the number of lines in each. I assume for simplicity that the last line in the file also ends with a newline character, so we need to count only the number of newline characters in the current file.&lt;/p&gt;
&lt;p&gt;Reasoning imperatively, you might implement the solution decomposing it into the following steps :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open each file.&lt;/li&gt;
&lt;li&gt;Define a counter to store the number of lines.&lt;/li&gt;
&lt;li&gt;Read the file one character at a time, and increase the counter every time the newline character (\n) occurs.&lt;/li&gt;
&lt;li&gt;At the end of a file, store the number of lines calculated.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following algorithm implements the steps listed before. In summary, we are reading the files character by character and counts the number of newline characters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Calculating the number of lines the imperative way
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count_lines&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; filename)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; new_line_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ifstream infile(filename);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ch;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (infile.get(ch)) 
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ch &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;)
            new_line_count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; new_line_count;
}
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; count_lines_in_files(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; files)
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; lines_in_each_file(files.size());
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; file : files) 
    {
        lines_in_each_file.push_back(count_lines(file));
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; lines_in_each_file;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, we are moving this code to a more functional one. The first version exploits a set of C++ abstractions, such as use the standard std::count algorithm instead of counting the number of newlines manually and the stream iterators  that allow us to treat the I/O streams similarly to ordinary collections like lists and vectors.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//functionalizing the code.... 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count_lines&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; filename)
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ifstream infile(filename);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;count(
                   std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;istreambuf_iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(infile),           
                   std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;istreambuf_iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;);
}
&lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; count_lines_in_files(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; files)
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; lines_in_each_file(files.size());
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; file : files) 
    {
        lines_in_each_file.push_back(count_lines(file)); 
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; lines_in_each_file;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When we compare the solutions presented above, we can notice that the main change occurred on the &lt;code&gt;count_lines&lt;/code&gt; function.
Now, his only task is to convert its input (the filename) to the type that &lt;code&gt;std::count&lt;/code&gt; can understand: a pair of stream iterators. In this way, we are no longer concerned about how to implement the counting new lines algorithm. We are just declaring that we want to count the number of newlines that appears in the given input stream.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s quite common to use the number of lines of code (LOC) to measure the complexity of a program. Although LOC can perfectly express the difference in the complexity between imperative and functional solutions, I prefer to highlight another benefit from the functional solution: The fewer state variables to worry about. Each program has an implicity conceptual state machine binds to it. The correct management of state changes into a program is one of the most significant sources of software bugs. I believe that by reducing the number of states to keep track, we reducing the number of bugs.&lt;/p&gt;
&lt;p&gt;Therefore, the main idea in the functional style is to use
abstractions to express the higher-level intent of an algorithm instead of specifying how to do something.&lt;/p&gt;
&lt;p&gt;But, we can do even better. We can convert the entire algorithm to functional style, a.k.a. we are going to specify what should be done, instead of how it should be done. I know that I&amp;rsquo;m being repeating but it&amp;rsquo;s important to consolidate this principle in our minds.&lt;/p&gt;
&lt;p&gt;To start, we need an abstraction that allows us to applies a function to all elements in a collection and collects the results. Fortunately, The STL designed the &lt;code&gt;std::transform&lt;/code&gt; algorithm for this. Essentially, the &lt;code&gt;std::transform&lt;/code&gt; abstraction applies a function to each element of a range defined by a pair of iterators and write the results somewhere.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; count_lines_in_files(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; files)
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; lines_in_each_file(files.size());
    &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;transform(
        files.cbegin(), files.cend(), 
        lines_in_each_files.begin(), 
        count_lines                
    );
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; lines_in_each_files;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The new implementation of the &lt;code&gt;count_lines_in_files&lt;/code&gt; applies the &lt;code&gt;std::transform&lt;/code&gt; in each element of the files collection one by one,
transforms them using the &lt;code&gt;count_lines&lt;/code&gt; function, and stores the resulting values in the &lt;code&gt;lines_in_each_file&lt;/code&gt; vector.&lt;/p&gt;
&lt;p&gt;This code no longer specifies the algorithm steps that need to be taken, but rather how the input should be transformed in order to
get the desired output. But, what&amp;rsquo;s the big deal here? This solution makes the code less prone to errors, since it removes the state
variables, and rely on the standard library implementation of the counting algorithm instead of rolling your own.&lt;/p&gt;
&lt;h2 id=&#34;bonus-track-range-library---c20&#34;&gt;BONUS TRACK: Range Library - C++20&lt;/h2&gt;
&lt;p&gt;We can remove the boilerplate code from the previous functional solutions to be considered more readable than the imperative version.
We can use the C++ 20 std::ranges library to do it. (I think that we can talk about ranges in near future, ranges concepts will be a big improvement on STL).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count_lines&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; filename)
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ifstream in(filename);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;count( 
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;istreambuf_iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(in), 
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;istreambuf_iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;);
}

std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; count_lines_in_files(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; files)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; rng &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; files 
                &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ranges&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;views&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;transform(count_lines);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(rng.begin(), rng.end());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This solution is much less verbose than the imperative solution and much more obvious.&lt;/p&gt;
&lt;h2 id=&#34;pure-functions&#34;&gt;Pure functions&lt;/h2&gt;
&lt;p&gt;One of the most significant sources of software bugs is program state management. Every program has an implicity state machine binds to him.  It’s difficult to keep track of all possible states of a program and its transitions. The OOP paradigm provides the means to group parts of the state into objects, thus making it easier to manage. But it doesn’t significantly reduce the number of possible states neither the number of possible transitions.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bartoszmilewski.com/2015/04/15/category-theory-and-declarative-programming/&#34;&gt;https://bartoszmilewski.com/2015/04/15/category-theory-and-declarative-programming/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.webix.com/difference-between-declarative-and-imperative-programming-with-language-examples/&#34;&gt;https://blog.webix.com/difference-between-declarative-and-imperative-programming-with-language-examples/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Functional Programming in C++&lt;/li&gt;
&lt;li&gt;Learning C++ Functional Programming&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Pointers References Optional Cpp</title>
      <link>https://jdiego.github.io/posts/pointers-references-optional-cpp/</link>
      <pubDate>Sun, 13 Jun 2021 22:58:13 -0300</pubDate>
      
      <guid>https://jdiego.github.io/posts/pointers-references-optional-cpp/</guid>
      <description>Pointers, References and Optional in C++ </description>
      <content>&lt;h1 id=&#34;pointers-references-and-optional-in-c&#34;&gt;Pointers, References and Optional in C++&lt;/h1&gt;
</content>
    </item>
    
    <item>
      <title>Compile-time type introspection in C&#43;&#43;</title>
      <link>https://jdiego.github.io/posts/introspection_in_cpluplus/</link>
      <pubDate>Thu, 03 Jun 2021 18:52:06 -0300</pubDate>
      
      <guid>https://jdiego.github.io/posts/introspection_in_cpluplus/</guid>
      <description>Introduction C++ a language designed to be written in a human-readable format and then compiled directly into a bunch of CPU-readable instructions. The only information we could get in touch within a runtime environment is those values stored on heap and stack since after an executable file was loaded into main memory and started to execute, the available scope of the program itself is bound by its own virtual mapped memory space.</description>
      <content>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;C++ a language designed to be written in a human-readable format and then compiled directly into a bunch of CPU-readable instructions. The only information we could get in touch within a runtime environment is those values stored on heap and stack since after an executable file was loaded into main memory and started to execute, the available scope of the program itself is bound by its own virtual mapped memory space.  This model assumes that we’d write the human-readable source code, and later let the compiler translate them into whatever a CPU understands. It is totally fine for quite a lot of usage cases.&lt;/p&gt;
&lt;p&gt;But, there is a wide range of computer programming tasks that involve the execution of the same algorithm on a set of types defined by an application or on instances of these types, accessing member variables, calling free or member functions in an uniform manner, converting  data between the language’s intrinsic representation and external formats, etc. We can use as example the serialization of persistent data in a custom binary format or in XML,JSON, etc. In this kind of task, you’d want the program to know itself in a human-readable way and feedback the user these pieces of information in runtime. An way to automate these tasks is to use reflection.&lt;/p&gt;
&lt;p&gt;The ability of a program to examine the type or properties of an object at runtime is called introspection, and if it could furthermore modify its own structure and behaviour at runtime then it’s called intercession, the combination of these two abilities is named reflection. The ability of a program to exame the type or properties of an object at runtime is called introspection, and if it could furthermore modify itself then it’s called intercession, the combination of these two abilities is named reflection. To be clear: reflection is the ability examine, introspect, and modify its own structure and behavior at runtime. Python, Java, Ruby, Typescript and a bunch of other languages come with reflection baked in the language. But, and what about C++?&lt;/p&gt;
&lt;p&gt;As we’ve known, unfortunately, C++ doesn&amp;rsquo;t outstand when it comes to reflection features in runtime. It&amp;rsquo;s designed to be statically built but with the ability to perform dynamic behaviour. All the execution procedures are pre-defined by the programmer, and we’d use the conditional branch and the polymorphism to achieve dynamic in runtime. But when we want some introspection capabilities, the best ability provided by default is  Run-Time Type Identification (RTTI), nevertheless, not only RTTI isn&amp;rsquo;t always available, once that it&amp;rsquo;s compiler-specific,
but the RTTI also gives you barely more than the current type of the manipulated object. As we can noticed in the following code snippet:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;typeinfo&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Base&lt;/span&gt; { 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Base() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// polymorphic
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};

&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Derived&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; Base {};

Derived d;
Base&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d;

&lt;span style=&#34;color:#75715e&#34;&gt;//NOTE: The string returned by typeid::name is implementation-defined
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typeid&lt;/span&gt;(b).name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Thus, C++ doesn’t provide us facilities to get runtime reflection easy; and it is often criticized for this, but it doesn’t mean it doesn’t have any reflection capabilities.&lt;/p&gt;
&lt;p&gt;In this post, we’re gonna explore what introspection features are currently available to us and what is possible to achieve given its limitations. This post is based on &lt;a href=&#34;https://jguegant.github.io/blogs/tech/sfinae-introduction.html&#34; title=&#34;An introduction to C++&#39;s SFINAE concept: compile-time introspection of a class member&#34;&gt;Jean Guegant&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;introspection-broken-down&#34;&gt;Introspection Broken Down&lt;/h1&gt;
&lt;p&gt;To shortly recap, type introspection is the feature of reflection to ask the object something about something in particular. For example, you could ask an object if it has a serialize member function in order to call it, or you could query the object to know if it has a given data member. What we’re doing here is basically inspect the object to check if it fulfils a contract or a set of criteria - concept feelings, I know but this is subject to another post.&lt;/p&gt;
&lt;p&gt;C++ offers a quite powerful way to inspect whether an object has a specific member or not: &lt;code&gt;SFINAE&lt;/code&gt;. Before explaining what is SFINAE and what this acronym stands for, let&amp;rsquo;s explore one of main motivation example to reflection: serialization. For instance, in Python, using reflection off course, one can do the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PyA&lt;/span&gt;(object):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __str__(self):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a A&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PyB&lt;/span&gt;(object):
    &lt;span style=&#34;color:#75715e&#34;&gt;# Specialize method for serialization.&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;serialize&lt;/span&gt;(self):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a B&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PyC&lt;/span&gt;(object):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self):
        &lt;span style=&#34;color:#75715e&#34;&gt;# NOTE: &amp;#39;serialize&amp;#39; is not a method. &lt;/span&gt;
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;serialize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __str__(self):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a C&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;serialize&lt;/span&gt;(obj):
    &lt;span style=&#34;color:#75715e&#34;&gt;# Let&amp;#39;s check if obj has an attribute called &amp;#39;serialize&amp;#39;.&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; hasattr(obj, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;serialize&amp;#34;&lt;/span&gt;):
        &lt;span style=&#34;color:#75715e&#34;&gt;# Let&amp;#39;s check if this &amp;#39;serialize&amp;#39; attribute is a method.&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; hasattr(obj&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;serialize, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__call__&amp;#34;&lt;/span&gt;):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; obj&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;serialize()

    &lt;span style=&#34;color:#75715e&#34;&gt;# Else we call the __str__ method.&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; str(obj)

a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PyA()
b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PyB()
c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PyC()

print(serialize(a)) &lt;span style=&#34;color:#75715e&#34;&gt;# output: I am a A.&lt;/span&gt;
print(serialize(b)) &lt;span style=&#34;color:#75715e&#34;&gt;# output: I am a B.&lt;/span&gt;
print(serialize(c)) &lt;span style=&#34;color:#75715e&#34;&gt;# output: I am a C.&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The Python code above show us that introspection comes pretty handy during serialization process. Once that we can check if an object has an attribute and to query the type of this attribute. In our Python example, introspection permits us to use the serialize method if available and fall back to the more generic method otherwise. Great job! We can do it in plain C++ too!. So, our goal now is to bring the fowolling code a life.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;A() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string serialize() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a B!&amp;#34;&lt;/span&gt;; }
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; { 
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string serialize; 
};


&lt;span style=&#34;color:#75715e&#34;&gt;// Function overloads to A and B types 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string to_string(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;){ &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a A!&amp;#34;&lt;/span&gt;;}
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string to_string(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;){ &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a C!&amp;#34;&lt;/span&gt;;}

std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; serialize(a)) &lt;span style=&#34;color:#75715e&#34;&gt;// output: I am a A.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; serialize(b)) &lt;span style=&#34;color:#75715e&#34;&gt;// output: I am a B.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; serialize(c) &lt;span style=&#34;color:#75715e&#34;&gt;// output: I am a C.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I&amp;rsquo;m going to start with the using the C++98 to present the C++ evolution during last years. I pretend to combat the wrong idea that C++ don´t evolves I&amp;rsquo;m going to start with the using the C++98, but don´t worry, I will present the modern form too. My secondary goal with this post is  combat the wrong idea that C++ doesn&amp;rsquo;t evolves. So, exposing the reader to the old forms and new ones gives to him a view about the language progress&lt;/p&gt;
&lt;h1 id=&#34;the-c98-way&#34;&gt;The C++98-way&lt;/h1&gt;
&lt;p&gt;The solution presented below relies on 3 key concepts: &lt;code&gt;overload resolution&lt;/code&gt;, the static behavior of &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;SFINAE&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;overload-resolution&#34;&gt;Overload resolution:&lt;/h2&gt;
&lt;p&gt;Overload resolution is the process that selects the function to call for a given call expression. Consider the following simple example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;display_num&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// #1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;display_num&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;);   &lt;span style=&#34;color:#75715e&#34;&gt;// #2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
{
    display_num(&lt;span style=&#34;color:#ae81ff&#34;&gt;399&lt;/span&gt;);       &lt;span style=&#34;color:#75715e&#34;&gt;// #1 matches better than #2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    display_num(&lt;span style=&#34;color:#ae81ff&#34;&gt;3.99&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// #2 matches better than #1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this example, the function name display_num() is said to be overloaded. When this name is used in a call, a C++ compiler must therefore distinguish between the various candidates using additional information; mostly, this information is the types of the call arguments. The rule of thumb in this case is the compiler picks the candidate function whose parameters match the arguments most closely is the one that is called.  So far, so go, but in C++ we also have some sink-hole functions that accept everything: the variadic functions. Variadic functions are functions (e.g. printf) which take a variable number of arguments of any type. How does this work? Nothing is better than an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(...);  &lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; print(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; t); &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
print(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Call the templated function version of f.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I need that you keep in mind that C++ prefer non-templates and templates functions over variadic functions! Finally, a picture speaks a thousand words:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jdiego.github.io/CPlusPlusResolvesFunctionCall.png&#34; alt=&#34;OverloadResolution&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sfinae-substitution-failure-is-not-an-error&#34;&gt;SFINAE (Substitution Failure Is Not An Error)&lt;/h2&gt;
&lt;p&gt;Let’s start with a C++ principle behind this concept: The compiler can reject code that &amp;ldquo;would not compile&amp;rdquo; for a given type to provide protection only against attempts to create invalid types but not against attempts to evaluate invalid expressions. We call this principle SFINAE (pronounced like sfee-nay), which stands for &amp;ldquo;substitution failure is not an error&amp;rdquo;. In rough terms, SFINAE is a rule that applies during overload resolution for templates. If substituting the template parameter with the deduced type fails, the compiler won’t report an error; it’ll ignore that particular overload. Let me show an example again:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// number of elements in a raw array:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_t len (T(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;)[N])
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; N;
}
&lt;span style=&#34;color:#75715e&#34;&gt;// number of elements for a type having size_type:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_type len (T &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; t)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; t.size();
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;];
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; len(a);        &lt;span style=&#34;color:#75715e&#34;&gt;// OK: only len() for array matches
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; len(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tmp&amp;#34;&lt;/span&gt;);    &lt;span style=&#34;color:#75715e&#34;&gt;//OK: only len() for array matches
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;};
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; len(v);        &lt;span style=&#34;color:#75715e&#34;&gt;// OK: only len() for a type with
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, we define two function templates len() taking one generic argument:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first function template declares the parameter as T(&amp;amp;)[N], which means that
the parameter has to be an array of N elements of type T.&lt;/li&gt;
&lt;li&gt;The second function template declares the parameter simply as T and requires that the passed argument
type has a corresponding member size_type and return it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;According to its signature, the second function template also matches when substituting (respectively) int[10] and char const[4] for T, but those substitutions lead to potential errors in the return type size_type. The second template is therefore ignored for these calls. Analogously, when passing a std::vector, only the second function template matches and the first one is ignored.&lt;/p&gt;
&lt;h2 id=&#34;the-operator-sizeof&#34;&gt;The operator sizeof:&lt;/h2&gt;
&lt;p&gt;There is a surprising amount of power in sizeof; this is because you can apply sizeof to any expression, no matter how complex, and sizeof returns its size, without actually evaluating that expression at runtime. This means that sizeof is aware of overloading, template instantiation, conversion rules — everything that can take part in a C++ expression. In fact, sizeof is a complete facility for deducing the type of an expression; eventually, sizeof throws away the expression and returns you only the size of its result. To remember: sizeof returns the size of the object of the type that would be returned by expression, if evaluated.&lt;/p&gt;
&lt;p&gt;The real power with sizeof comes in when we start using function overloads. If we have 2 versions of the same function, we can pass some parameters to that function, and the compiler will figure out which function is the best match. If each function has differently sized return types, we can use sizeof to discriminate which one the compiler chose for any given parameters. Are you ready? Let&amp;rsquo;s go:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; no;        
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; yes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];    

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
yes test(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
no test(...);

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(f&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(f&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// output: 0 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(f&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(f&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// output: 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Calling a function with ellipsis with a C++ object has undefined results, but who cares? Nobody actually calls the function.
It’s not even implemented!&lt;/p&gt;
&lt;p&gt;What&amp;rsquo;s the point here? We found a way to exploit the sizeof operator to detect whether an arbitrary type T has the same signature as another arbitrary type U! Thus, we can pass a type and use this technique to check if satisfies the expected signature. Here we are going again&amp;hellip;..&lt;/p&gt;
&lt;p&gt;NOTE: Here is one little problem. What if T makes its default constructor private? In this case, the expression T fails to compile and so does all of our scaffolding. Fortunately, there is a simple solution — just use a strawman function returning a T.&lt;/p&gt;
&lt;h2 id=&#34;the-working-serialize&#34;&gt;The working serialize&lt;/h2&gt;
&lt;p&gt;First, I would like to show you a tricky implemention developed by &lt;a href=&#34;https://jguegant.github.io/blogs/tech/sfinae-introduction.html&#34; title=&#34;An introduction to C++&#39;s SFINAE concept: compile-time introspection of a class member&#34;&gt;Jean Guegant&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;has_serialize&lt;/span&gt;
{
    &lt;span style=&#34;color:#75715e&#34;&gt;// For the compile time comparison.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; no;        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; yes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];    

    &lt;span style=&#34;color:#75715e&#34;&gt;// 1 - This helper struct permits us to check two properties of a template argument.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; U, U u&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;has_member&lt;/span&gt;;

    &lt;span style=&#34;color:#75715e&#34;&gt;// 2 - Two overloads for yes: one if for the signature of a normal method,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// one is for the signature of a const method.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; yes&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; test(has_member&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string (C&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;)(), &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;*&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/*unused*/&lt;/span&gt;);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; yes&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; test(has_member&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string (C&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;)() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;*&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/*unused*/&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 3 - The C++ sink-hole for failback.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; no&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; test(...);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 4 - The test is actually done here, thanks to the sizeof compile-time evaluation.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(test&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(yes);
};

&lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// output: 0 - A hasn&amp;#39;t a serialize method 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;B&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// output: 1 - B has a serialize method
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// output: 0 - C has&amp;#39;t a serialize method.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that here we&amp;rsquo;re using the size of the return value to check how the overloaded has_member function is resolved. It is tricky, I know. To aid clarity: the helper struct &lt;code&gt;has_member&lt;/code&gt; checks whether &lt;code&gt;&amp;amp;C::serialize&lt;/code&gt; has the same signature as the first argument! For example, for the  &lt;code&gt;has_serialize&amp;lt;B&amp;gt;&lt;/code&gt; call, the &lt;code&gt;has_member&amp;lt;std::string (C::*)(), &amp;amp;C::serialize&amp;gt;&lt;/code&gt; should be substituted by &lt;code&gt;has_member&amp;lt;std::string (C::*)(), std::string (C::*)() &amp;amp;C::serialize&amp;gt;&lt;/code&gt; and work!&lt;/p&gt;
&lt;p&gt;As we restrict ourselves to C++98, we lose decltype and declval, which are the main driver of this language in C++11 onwards. Don´t be panic; We can emulate this by abusing sizeof again.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
T declval();

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;has_serialize&lt;/span&gt;
{
    &lt;span style=&#34;color:#75715e&#34;&gt;// the size of the array, is determined by our sizeof expression.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; yes&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; test(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)[&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(declval&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;().serialize(), &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)]);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 2 - The C++ sink-hole for failback.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; no&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; test(...);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 3 - The test is actually done here, thanks to the sizeof compile-time evaluation.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(test&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(yes);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, we&amp;rsquo;re passing a pointer to a fixed size array &lt;code&gt;int (*) [x]&lt;/code&gt;, where x, this will SFINAE out if our type does not have the
method &lt;code&gt;serialize&lt;/code&gt;, just like the previous ones, and will return 1 otherwise.&lt;/p&gt;
&lt;p&gt;Now you would think that it will be handle to use our &lt;code&gt;has_serialize&lt;/code&gt; to create a serialize function like the Python one:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string serialize(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; obj) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value) { &lt;span style=&#34;color:#75715e&#34;&gt;// Dead branch for a?
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; obj.serialize();
    } 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;to_string(obj);   
    }
}
&lt;span style=&#34;color:#75715e&#34;&gt;// 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;A a; 
serialize(a); &lt;span style=&#34;color:#75715e&#34;&gt;// ERROR: no member named &amp;#39;serialize&amp;#39; in &amp;#39;A&amp;#39;.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But, what&amp;rsquo;s wrong with this solution? Why the compiler reclaims? If you consider the code that you will obtain after substitution and compile-time evaluation, we can understand the reason the error raised by your compiler is absolutely normal:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string serialize(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; obj)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// Dead branch 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; obj.serialize(); &lt;span style=&#34;color:#75715e&#34;&gt;// error: no member named &amp;#39;serialize&amp;#39; in &amp;#39;A&amp;#39;.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    } 
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;to_string&lt;/span&gt;(obj);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The compilers won&amp;rsquo;t drop any dead-branch, and &lt;code&gt;obj&lt;/code&gt; must therefore have both a &lt;code&gt;serialize&lt;/code&gt; method and a &lt;code&gt;to_string&lt;/code&gt; overload in this case.
We need a different technique, we need a way to force compilers to behave as if a particular template didn’t exist. Such templates are said to be disabled. Since, by default, all templates are enabled.&lt;/p&gt;
&lt;p&gt;The solution is to apply an SFINAE mechanism to ensure that function templates are ignored for certain constraints by instrumenting the template code to result in invalid code for these constraints. So, using SFINAE we ​can construct a type that will allow us to guide overload resolution and discard candidate functions based on conditions known at compile-time. I bring to life the last piece of the puzzle called enable_if.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;//1 - Default template version.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;enable_if&lt;/span&gt;
{};  &lt;span style=&#34;color:#75715e&#34;&gt;// This struct doesn&amp;#39;t define &amp;#34;type&amp;#34; and the substitution will fail if you try to access it.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// 2 -  A partial-specialisation recognizes if the expression is true. 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;enable_if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;true, T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; T type; &lt;span style=&#34;color:#75715e&#34;&gt;// This struct do have a &amp;#34;type&amp;#34; and won&amp;#39;t fail on access.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};

&lt;span style=&#34;color:#75715e&#34;&gt;// 3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;enable_if&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;true, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;type t1; &lt;span style=&#34;color:#75715e&#34;&gt;// OK: The first argument is true so type is int.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;enable_if&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;false, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;type t2; &lt;span style=&#34;color:#75715e&#34;&gt;// ERROR: The fisr argument is false so no type named &amp;#39;type&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;enable_if&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;B&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;type t3; &lt;span style=&#34;color:#75715e&#34;&gt;// OK: B has a serialize method and t3::type is int.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;enable_if&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;type t4; &lt;span style=&#34;color:#75715e&#34;&gt;// ERROR: A hasn&amp;#39;t a serialize method and no type named &amp;#39;type&amp;#39;.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In 1, the base template does not define any member types, but the partial specialization on true does in 2. This means, if the condition evaluates to false, the substitution fails and the candidate will be discarded. Do you know what this means? We can trigger a substitution failure according to a compile time expression with enable_if.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; enable_if&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;type serialize(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; obj)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; obj.serialize();
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; enable_if&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;not has_serialize&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;type serialize(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; obj)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;to_string&lt;/span&gt;(obj);
}

A a;
B b;
C c;

&lt;span style=&#34;color:#75715e&#34;&gt;// The following lines work like a charm!
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; serialize(a) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; serialize(b) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; serialize(c) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note SFINAE at work here. When we make the &lt;code&gt;serialize(B b)&lt;/code&gt;, the compiler selects the first overload: since the condition &lt;code&gt;has::serialize&amp;lt;B&amp;gt;&lt;/code&gt; is true, the specialization of struct &lt;code&gt;enable_if&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; is used, and its internal type is set to &lt;code&gt;int&lt;/code&gt;. The second overload is omitted because without the &lt;code&gt;true&lt;/code&gt; specialization (&lt;code&gt;not has_serialize&amp;lt;A&amp;gt;::value&lt;/code&gt; is false) the general form of struct &lt;code&gt;enable_if&lt;/code&gt; is selected, and it doesn&amp;rsquo;t have a type, so the type of the argument results in a substitution failure.&lt;/p&gt;
&lt;p&gt;Thus, we want one of the two functions to be instantiated for a given type T. In other words, we explicitly manage the overload set at compile-time.&lt;/p&gt;
&lt;p&gt;NOTE: enable_if is so important that it was introducted at C++11 in STL. For C++11 and beyond, you can use std::enable_if.&lt;/p&gt;
&lt;h1 id=&#34;links&#34;&gt;LINKS&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://jguegant.github.io/blogs/tech/sfinae-introduction.html&#34;&gt;Jean Guegant&lt;/a&gt;: An introduction to C++&amp;rsquo;s SFINAE concept: compile-time introspection of a class member&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;https://preshing.com/20210315/how-cpp-resolves-a-function-call/&#34;&gt;Jean Guegant&lt;/a&gt;: How C++ Resolves a Function Call&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&#34;https://gracicot.github.io/reflection/2018/04/03/reflection-present.html&#34;&gt;Guillaume Racicot&lt;/a&gt;: Reflection in C++ Part 1: The Present&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
